---
{"dg-publish":true,"permalink":"/learning-notes/docker/docker-image-size/","created":"2024-12-23T00:57:40.929+09:00","updated":"2024-12-23T02:17:57.183+09:00"}
---

## Docker Image가 클 때의 문제점
- ML 프레임워크와 모델을 포함한 도커 이미지를 빌드하게 되면 사이즈가 매우 커지게 됨
- 매우 큰 도커 이미지는 빌드 타임, 런타임, 호스트 머신 디스크 3가지 부분에서 문제를 가지게 됨
- **빌드 타임 관점** 
	- 빌드 속도 : 새로운 이미지로 교체하기 위해 기다려야하는 시간이 늘어나서, 신속한 대응이 어려워짐
	- 네트워크 전송 비용 : 푸시, 풀 비용
	- 각종 비용 : 디스크 용량, 빌드 시간에 따라 비용이 늘어남
- **런타임 관점** 
	- 컨테이너 시작 시 메모리에 로드되는 용량이 매우 큼
	- 이미지 풀 시 기다리는 시간이 매우 길어짐
- **호스트 머신 디스크**
	- 이미지의 용량이 매우 커서 VM 인스턴스 환경에서 디스크에 대한 용량 관리가 필요함
	- 클라우드 환경의 디스크 용량은 비용과 직결되기 때문에 주의해야 함

## Docker Image Size 최적화
- 작은 배이스 이미지를 선정해서 사용하기
	- 알맞은 Base Image를 찾는 게 중요
	- 사용할 OS package들만 설치 후 사용, bash, zsh등 shell 환경이 안 깔려 있을수도 있음
	- 파이썬
		- 표준 이미지 : python:3.9
		- 슬림 이미지 : python:3.9-slim : 슬림한 데비안 이미지 기반, Production 환경에 적합
		- 알파인 이미지 : python3.9-alpine : Alpine Linux 기반으로 사용, 작은 크기, 종속성은 수동 설치해야 할 수도 있음
- Multi Stage Build 활용하기
	- 도커 이미지를 효율적으로 작성하고 최적화하기 위한 방법
	- 빌드에는 필요하지만 최종 컨테이너 이미지에는 필요없는 내용들을 제외시키면서 이미지를 생성하는 방법
	- 하나의 도커 파일에 여러 이미지를 빌드하여 사용
	- 베이스 이미지를 바꾸면서 2개 이상의 Dockerfile이 있는 것처럼 빌드를 수행하기도 함
	- COPY의 --from 옵션을 통해 실행 이미지로 전달할 수 있음
	- Multi Stage
		- build와 runtime 부분으로 나누고 Copy --from=build를 통해서 필요한 부분들만 추출하여 사용
		- 예시)
			- build에서는 base image를 python:3.9를 사용하고
			- runtime에서는 base image로 python:3.9-slim을 사용하면서 필요한 부분들을 Copy --from=build/root/.local 에서 가져옴
- Container 패키징하기
	- .dockerignore로 필요없는 파일들 제거
	- .pt, .pth와 같은 큰 모델 파일들은 빌드에 포함하지 않고 빌드 타임 혹은 컨테이너 시작하는 스크립트에서 따로 다운로드
	- Dockerfile 안에서 command들의 순서 최적화를 통해 캐싱을 최대한 이용
		- 변경 가능성이 낮은 명령어를 위로, 변경 가능성이 높은 명령어는 아래에 위치
		- 나중에 바꿀 가능성이 낮은 명령어부터 수행하면 나중에 바꾸더라도 그 전 명령어까지는 캐시를 이용 가능